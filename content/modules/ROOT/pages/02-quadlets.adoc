== Files

We’ve created some clean files for you to use inside of `+~/my-app+`.
You will notice two files in that directory. `+my-app.yaml+` and
`+my-app-configmap.yaml+`. We have taken the environment variables for
the MariaDB container, and split them out into a ConfigMap. A ConfigMap
is a file which is meant to make it easier to maintain your environment
and configuration settings.

You can feel free to review the contents of these files.

Pod deployment file

[source,bash,run]
----
cat ~/my-app/my-app.yaml
----

ConfigMap file

[source,bash,run]
----
cat ~/my-app/my-app-configmap.yaml
----

You can build a pod using these two files using the following command.

[source,bash,run]
----
podman play kube --configmap ~/my-app/my-app-configmap.yaml ~/my-app/my-app.yaml
----

Now you should have your pod running again.

[source,bash,run]
----
podman pod ps
----

But the goal here is to try to run this using Quadlet, so instead, let’s
do that.

[source,bash,run]
----
podman pod stop my-app && podman pod rm my-app
----

With the pod stopped and removed, let’s move into how Quadlet works.

== How Quadlet works

Quadlet can be used to define podman resources such as containers, pods,
even volumes, using systemd. Quadlet is a systemd generator, which takes
your podman definition, and turns it into a dynamically generated
systemd unit. This unit will start a new instance of your resource when
you start it, and destroy it when you stop it. This fits container
workflows very well, because there should be no reason to keep the old
containers around once they’re stopped, and starting a new instance of
the container from the latest copy (or the latest build of the tag you
are following) of the source image is also a good practice.

We have created some quadlet definitions for you inside of
`+~/my-app/quadlet+`, so let’s have a look at them.

[source,bash,run]
----
cd ~/my-app/quadlet
----

Now have a look at `+my-app.kube+`

[source,bash,run]
----
cat my-app.kube
----

The `+.kube+` extension tells Quadlet that this is a generated Kube
definition from Podman. There are several other extensions that Quadlet
supports, such as `+.container+`, `+.pod+`, and `+.volume+`.

It doesnt really matter where you save your pod’s Kube definition, or
the Configmap Yaml, but it’s good practice to place them somewhere
common, and not in your home directory. Unless you are creating systemd
user units, which is possible with Quadlet as well, but we are not
covering those in this lab. You might notice that we’ve defined the
paths to the two required files within the quadlet definition as
`+/etc/containers/systemd+`. This is also where the .kube file needs to
be placed for a system level unit file, so let’s copy all of the files
there.

[source,bash,run]
----
cp ~/my-app/my-app.yaml ~/my-app/my-app-configmap.yaml ~/my-app/quadlet/my-app.kube /etc/containers/systemd
----

Now, we can test to see what Quadlet will generate for our systemd unit
file using quadlet’s `+--dryrun+` command line option.

[source,bash,run]
----
/usr/libexec/podman/quadlet --dryrun
----

You should see the dry run output displayed in the terminal.

Now, to generate the output for real, all we will need to do is reload
systemd.

[source,bash,run]
----
systemctl daemon-reload
----

Let’s start it up.

[source,bash,run]
----
systemctl start my-app
----

As you would with any systemd service, you can check the status and log
output using the usual `+systemctl+` and `+journalctl+` commands.

[source,bash,run]
----
systemctl status --no-pager my-app
----

[source,bash,run]
----
journalctl --no-pager -xeu my-app
----

And of course you should see the pod running in podman

[source,bash,run]
----
podman pod ps
----

Now, if we stop the service, the pod will not just stop, but it gets
removed.

[source,bash,run]
----
systemctl stop my-app
podman pod ps
----

And of course if we start it back up, it will start with a new pod.

[source,bash,run]
----
systemctl start my-app
podman pod ps
----

In the next step, we’ll automate the deployment of our pod using RHEL
System Roles.
